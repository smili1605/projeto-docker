name: CI/CD COMPLETO - Terraform + Docker + DigitalOcean
on:
  push:
    branches: ["main"]

env:
  REGISTRY: docker.io
  IMAGE_NAME: python-app

jobs:
  # 1. BUILD - ConstrÃ³i e envia imagem Docker
  build-docker:
    name: ğŸ³ Build Docker Image
    runs-on: ubuntu-latest
    outputs:
      docker_tag: ${{ steps.tag.outputs.sha }}
      image_name: ${{ steps.build.outputs.image }}

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ·ï¸ Gerar Tag da Imagem
        id: tag
        run: |
          SHA=$(echo $GITHUB_SHA | head -c7)
          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "ğŸ“¦ Tag gerada: $SHA"

      - name: ğŸ” Login no DockerHub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: ğŸ—ï¸ Construir e Enviar Imagem
        id: build
        run: |
          TAG=${{ steps.tag.outputs.sha }}
          IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/$IMAGE_NAME:$TAG"
          
          echo "ğŸ”¨ Construindo: $IMAGE"
          docker build -t $IMAGE .
          
          echo "ğŸ“¤ Enviando para DockerHub..."
          docker push $IMAGE
          
          echo "image=$IMAGE" >> $GITHUB_OUTPUT
          echo "âœ… Imagem enviada com sucesso!"

  # 2. TERRAFORM - Provisiona infraestrutura
  terraform-infra:
    name: â˜ï¸ Provisionar Infraestrutura
    runs-on: ubuntu-latest
    needs: build-docker
    outputs:
      droplet_ip: ${{ steps.get_ip.outputs.droplet_ip }}

    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ” Verificar Secrets
        run: |
          echo "ğŸ” VERIFICAÃ‡ÃƒO DE SECRETS"
          echo "========================"
          echo "TF_TOKEN: ${{ secrets.TF_TOKEN != '' && 'âœ…' || 'âŒ' }}"
          echo "DO_TOKEN: ${{ secrets.DO_TOKEN != '' && 'âœ…' || 'âŒ' }}"
          echo "SSH_PUBLIC_KEY: ${{ secrets.SSH_PUBLIC_KEY != '' && 'âœ…' || 'âŒ' }}"
          echo "========================"
          
          if [ -z "${{ secrets.DO_TOKEN }}" ]; then
            echo "ğŸš¨ ERRO: DO_TOKEN nÃ£o configurada!"
            exit 1
          fi

      - name: âš™ï¸ Configurar Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: "1.6.0"

      - name: ğŸ”„ Inicializar Terraform
        working-directory: ./terraform
        run: terraform init -input=false -no-color
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_TOKEN || secrets.TF_API_TOKEN }}
          TF_INPUT: "false"

      - name: ğŸ“‹ Criar Plano Terraform
        working-directory: ./terraform
        run: |
          echo "ğŸ“ Criando plano de execuÃ§Ã£o..."
          
          # Remove arquivos de lock antigos
          rm -f .terraform.tfstate.lock.info 2>/dev/null || true
          
          terraform plan \
            -var="do_token=${{ secrets.DO_TOKEN }}" \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" \
            -var="ssh_key_name=projeto-docker-$(date +%s)" \
            -input=false -no-color -out=tfplan
          
          echo "âœ… Plano criado com sucesso!"
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_TOKEN || secrets.TF_API_TOKEN }}

      - name: ğŸš€ Aplicar ConfiguraÃ§Ã£o
        id: apply
        working-directory: ./terraform
        run: |
          echo "ğŸš€ Aplicando configuraÃ§Ã£o da infraestrutura..."
          
          # Tenta aplicar (pode falhar se for workspace VCS)
          terraform apply -auto-approve \
            -var="do_token=${{ secrets.DO_TOKEN }}" \
            -var="ssh_public_key=${{ secrets.SSH_PUBLIC_KEY }}" \
            -input=false -no-color 2>&1 || echo "âš ï¸  Modo VCS detectado"
          
          # Verifica se aplicou com sucesso
          if terraform output -raw droplet_ip >/dev/null 2>&1; then
            echo "apply_status=success" >> $GITHUB_OUTPUT
          else
            echo "apply_status=vcs_mode" >> $GITHUB_OUTPUT
          fi
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_TOKEN || secrets.TF_API_TOKEN }}
        continue-on-error: true

      - name: ğŸŒ Obter IP do Droplet
        id: get_ip
        working-directory: ./terraform
        run: |
          echo "ğŸ“ Obtendo IP do Droplet..."
          
          # Aguarda alguns segundos para criaÃ§Ã£o
          sleep 15
          
          # Tenta obter o IP vÃ¡rias vezes
          for i in {1..5}; do
            IP=$(terraform output -raw droplet_ip 2>/dev/null || echo "")
            
            if [ -n "$IP" ] && [ "$IP" != "null" ] && [ "$IP" != "" ]; then
              echo "âœ… IP encontrado: $IP"
              echo "droplet_ip=$IP" >> "$GITHUB_OUTPUT"
              exit 0
            fi
            
            echo "â³ Tentativa $i/5 - Aguardando criaÃ§Ã£o do droplet..."
            sleep 10
          done
          
          echo "âš ï¸  IP nÃ£o disponÃ­vel ainda"
          echo "ğŸ’¡ Se estiver usando Terraform Cloud VCS:"
          echo "ğŸ”— Acesse: https://app.terraform.io/app/ProjetoDocker/projeto-docker"
          echo "droplet_ip=PENDING_APPROVAL" >> "$GITHUB_OUTPUT"
        env:
          TF_TOKEN_app_terraform_io: ${{ secrets.TF_TOKEN || secrets.TF_API_TOKEN }}

  # 3. DEPLOY - Implanta aplicaÃ§Ã£o no Droplet
  deploy:
    name: ğŸš€ Deploy no Droplet
    runs-on: ubuntu-latest
    needs: [build-docker, terraform-infra]
    
    steps:
      - name: ğŸ“¥ Checkout cÃ³digo
        uses: actions/checkout@v4

      - name: ğŸ” Preparar Chave SSH
        id: prepare_ssh
        run: |
          echo "ğŸ”§ Preparando chave SSH..."
          
          # Cria arquivo com a chave privada
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > /tmp/ssh_key
          
          # Remove caracteres problemÃ¡ticos
          sed -i 's/\\r//g' /tmp/ssh_key  # Remove \r do Windows
          sed -i 's/\\n/\n/g' /tmp/ssh_key  # Converte \n para quebras reais
          sed -i '/^$/d' /tmp/ssh_key  # Remove linhas vazias
          
          # Garante permissÃµes corretas
          chmod 600 /tmp/ssh_key
          
          # Verifica se a chave Ã© vÃ¡lida
          echo "ğŸ” Validando chave SSH..."
          if ssh-keygen -l -f /tmp/ssh_key 2>/dev/null; then
            echo "âœ… Chave SSH vÃ¡lida!"
          else
            echo "âŒ Chave SSH invÃ¡lida!"
            echo "ğŸ“‹ Formato esperado:"
            echo "-----BEGIN OPENSSH PRIVATE KEY-----"
            echo "..."
            echo "-----END OPENSSH PRIVATE KEY-----"
            exit 1
          fi

      - name: ğŸ”‘ Configurar SSH Agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: ğŸŒ Verificar Conectividade
        id: check_connectivity
        run: |
          IP="${{ needs.terraform-infra.outputs.droplet_ip }}"
          
          if [ "$IP" = "PENDING_APPROVAL" ] || [ -z "$IP" ]; then
            echo "â³ Aguardando criaÃ§Ã£o do droplet..."
            echo "ğŸ’¡ Acesse o Terraform Cloud para aprovar:"
            echo "ğŸ”— https://app.terraform.io/app/ProjetoDocker/projeto-docker"
            echo "skip_deploy=true" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ğŸ”— Testando conexÃ£o com $IP..."
          
          # Adiciona ao known_hosts
          mkdir -p ~/.ssh
          ssh-keyscan -H "$IP" >> ~/.ssh/known_hosts 2>/dev/null
          
          # Testa conexÃ£o SSH
          if timeout 30 ssh -o ConnectTimeout=10 -o BatchMode=yes -o StrictHostKeyChecking=no ubuntu@$IP "echo 'âœ… ConexÃ£o SSH OK'"; then
            echo "âœ… Droplet estÃ¡ acessÃ­vel"
            echo "skip_deploy=false" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸  Droplet nÃ£o estÃ¡ respondendo"
            echo "ğŸ’¡ Aguarde mais alguns minutos e tente novamente"
            echo "skip_deploy=true" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“¤ Enviar Arquivos para Droplet
        if: steps.check_connectivity.outputs.skip_deploy == 'false'
        run: |
          IP="${{ needs.terraform-infra.outputs.droplet_ip }}"
          
          echo "ğŸ“¤ Enviando arquivos para $IP..."
          
          # Envia arquivos necessÃ¡rios
          scp -o StrictHostKeyChecking=no -o ConnectTimeout=30 \
            docker-compose.yml \
            Dockerfile \
            requirements.txt \
            ubuntu@$IP:/home/ubuntu/
          
          echo "âœ… Arquivos enviados com sucesso!"

      - name: ğŸš€ Executar Deploy
        if: steps.check_connectivity.outputs.skip_deploy == 'false'
        run: |
          IP="${{ needs.terraform-infra.outputs.droplet_ip }}"
          TAG="${{ needs.build-docker.outputs.docker_tag }}"
          IMAGE="${{ needs.build-docker.outputs.image_name }}"
          
          echo "ğŸš€ INICIANDO DEPLOY"
          echo "=================="
          echo "ğŸ“ Droplet: $IP"
          echo "ğŸ“¦ Imagem: $IMAGE"
          echo "=================="
          
          # Executa comandos de deploy no droplet
          ssh -o StrictHostKeyChecking=no -o ConnectTimeout=30 ubuntu@$IP "
            set -e
            
            echo 'ğŸ“ Acessando diretÃ³rio...'
            cd /home/ubuntu
            pwd
            ls -la
            
            echo 'ğŸ“ Criando arquivo .env...'
            cat > .env << EOF
            DOCKER_IMAGE_TAG=$TAG
            DB_USER=${{ secrets.DB_USER || 'postgres' }}
            DB_PASS=${{ secrets.DB_PASS || 'password' }}
            DB_NAME=${{ secrets.DB_NAME || 'appdb' }}
            EOF
            
            echo 'ğŸ“„ ConteÃºdo do .env:'
            cat .env
            
            echo 'ğŸ” Fazendo login no DockerHub...'
            if [ -n '${{ secrets.DOCKERHUB_USERNAME }}' ] && [ -n '${{ secrets.DOCKERHUB_TOKEN }}' ]; then
              echo '${{ secrets.DOCKERHUB_TOKEN }}' | docker login -u '${{ secrets.DOCKERHUB_USERNAME }}' --password-stdin
            else
              echo 'âš ï¸  Credenciais DockerHub nÃ£o configuradas'
            fi
            
            echo 'ğŸ›‘ Parando containers existentes...'
            docker-compose down 2>/dev/null || true
            
            echo 'ğŸš€ Iniciando nova versÃ£o...'
            docker-compose up -d --build
            
            echo 'âœ… DEPLOY COMPLETO!'
            echo ''
            echo 'ğŸ“Š STATUS DOS CONTAINERS:'
            docker ps
            echo ''
            echo 'ğŸŒ APLICAÃ‡ÃƒO DISPONÃVEL EM:'
            echo "http://$IP:8080"
          "
          
          echo ""
          echo "ğŸ‰ DEPLOY FINALIZADO COM SUCESSO!"
          echo "ğŸŒ Acesse sua aplicaÃ§Ã£o: http://$IP:8080"

      - name: ğŸ“Š Resumo do Deploy
        run: |
          echo "========================================"
          echo "ğŸ“‹ RESUMO DO DEPLOYMENT"
          echo "========================================"
          echo "ğŸ³ Imagem Docker: ${{ needs.build-docker.outputs.image_name }}"
          echo "ğŸŒ Droplet IP: ${{ needs.terraform-infra.outputs.droplet_ip }}"
          echo "ğŸ”„ Status: ${{ steps.check_connectivity.outputs.skip_deploy == 'false' && 'âœ… DEPLOY EXECUTADO' || 'â³ AGUARDANDO' }}"
          
          if [ "${{ steps.check_connectivity.outputs.skip_deploy }}" = "true" ]; then
            echo ""
            echo "ğŸ’¡ PRÃ“XIMOS PASSOS:"
            echo "1. Acesse o Terraform Cloud"
            echo "2. Aprove o plano de execuÃ§Ã£o"
            echo "3. Aguarde a criaÃ§Ã£o do droplet"
            echo "4. Execute este workflow novamente"
            echo ""
            echo "ğŸ”— Links:"
            echo "â€¢ Terraform Cloud: https://app.terraform.io/app/ProjetoDocker/projeto-docker"
            echo "â€¢ DockerHub: https://hub.docker.com/r/${{ secrets.DOCKERHUB_USERNAME }}/python-app"
          else
            echo ""
            echo "âœ… TUDO PRONTO!"
            echo "ğŸŒ URL da aplicaÃ§Ã£o: http://${{ needs.terraform-infra.outputs.droplet_ip }}:8080"
            echo "ğŸ”§ Comandos Ãºteis:"
            echo "  ssh ubuntu@${{ needs.terraform-infra.outputs.droplet_ip }}"
            echo "  docker logs python-app"
          fi
          echo "========================================"

  # 4. CLEANUP - Limpeza opcional
  cleanup:
    name: ğŸ§¹ Limpeza (Opcional)
    runs-on: ubuntu-latest
    if: always() && github.ref == 'refs/heads/main'
    needs: [deploy]
    
    steps:
      - name: ğŸ“¥ Checkout
        uses: actions/checkout@v4
      
      - name: ğŸ“ Log de ExecuÃ§Ã£o
        run: |
          echo "ğŸ§¹ ETAPA DE LIMPEZA"
          echo "=================="
          echo "Esta etapa Ã© opcional e pode ser usada para:"
          echo "â€¢ Limpar recursos temporÃ¡rios"
          echo "â€¢ Enviar notificaÃ§Ãµes"
          echo "â€¢ Registrar mÃ©tricas"
          echo ""
          echo "Status do deploy: ${{ needs.deploy.result }}"
          echo "=================="